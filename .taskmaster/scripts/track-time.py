#!/usr/bin/env python3
"""
Task time tracking with real datetime stamps.
Auto-generated by PRD-Taskmaster skill.
"""

from datetime import datetime, timezone
import json
import os
from pathlib import Path

class TaskTimer:
    """Track task execution time with precise datetime stamps."""

    def __init__(self, task_id, subtask_id=None):
        self.task_id = task_id
        self.subtask_id = subtask_id
        self.state_dir = Path(".taskmaster/state")
        self.state_dir.mkdir(parents=True, exist_ok=True)

        if subtask_id:
            self.state_file = self.state_dir / f"task-{task_id}-subtask-{subtask_id}.json"
        else:
            self.state_file = self.state_dir / f"task-{task_id}.json"

    def start(self):
        """Mark task/subtask as started with current UTC timestamp."""
        data = {
            "task_id": self.task_id,
            "subtask_id": self.subtask_id,
            "start_time": datetime.now(timezone.utc).isoformat(),
            "status": "in_progress"
        }
        with open(self.state_file, 'w') as f:
            json.dump(data, f, indent=2)

        start_time = datetime.now(timezone.utc).strftime("%Y-%m-%d %H:%M:%S UTC")
        print(f"📅 Started: {start_time}")

    def complete(self, notes=""):
        """Mark task/subtask as complete and calculate actual duration."""
        with open(self.state_file, 'r') as f:
            data = json.load(f)

        start = datetime.fromisoformat(data['start_time'])
        end = datetime.now(timezone.utc)

        duration_seconds = (end - start).total_seconds()
        duration_minutes = duration_seconds / 60
        duration_hours = duration_minutes / 60

        data.update({
            "end_time": end.isoformat(),
            "status": "completed",
            "actual_duration_seconds": int(duration_seconds),
            "actual_duration_minutes": round(duration_minutes, 2),
            "actual_duration_hours": round(duration_hours, 2),
            "notes": notes
        })

        with open(self.state_file, 'w') as f:
            json.dump(data, f, indent=2)

        # Format output
        if duration_hours >= 1:
            duration_str = f"{int(duration_hours)}h {int(duration_minutes % 60)}min"
        else:
            duration_str = f"{int(duration_minutes)} min"

        end_time = end.strftime("%Y-%m-%d %H:%M:%S UTC")
        print(f"✅ COMPLETED")
        print(f"📅 Ended: {end_time}")
        print(f"⏱️  Actual: {duration_str} ({duration_minutes:.1f} min)")

        return duration_minutes

    def get_duration(self):
        """Get current duration for in-progress task."""
        if not self.state_file.exists():
            return 0

        with open(self.state_file, 'r') as f:
            data = json.load(f)

        if data['status'] == 'completed':
            return data['actual_duration_minutes']

        start = datetime.fromisoformat(data['start_time'])
        now = datetime.now(timezone.utc)
        duration_minutes = (now - start).total_seconds() / 60
        return round(duration_minutes, 2)

def get_all_task_times():
    """Get timing data for all tasks."""
    state_dir = Path(".taskmaster/state")
    if not state_dir.exists():
        return []

    times = []
    for state_file in state_dir.glob("task-*.json"):
        with open(state_file, 'r') as f:
            data = json.load(f)
            if data['status'] == 'completed':
                times.append(data)

    return times

def calculate_accuracy(estimated_minutes, actual_minutes):
    """Calculate estimation accuracy percentage."""
    if estimated_minutes == 0:
        return 0
    accuracy = (actual_minutes / estimated_minutes) * 100
    return round(accuracy, 1)

if __name__ == "__main__":
    # CLI usage
    import sys

    if len(sys.argv) < 3:
        print("Usage: python track-time.py <command> <task_id> [subtask_id]")
        print("Commands: start, complete")
        sys.exit(1)

    command = sys.argv[1]
    task_id = sys.argv[2]
    subtask_id = sys.argv[3] if len(sys.argv) > 3 else None

    timer = TaskTimer(task_id, subtask_id)

    if command == "start":
        timer.start()
    elif command == "complete":
        timer.complete()
